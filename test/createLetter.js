'use strict';

// tests for createLetter
// Generated by serverless-mocha-plugin

const mochaPlugin = require('serverless-mocha-plugin');
const sandbox = require('sinon').createSandbox();;
const expect = mochaPlugin.chai.expect;
const request = require('request-promise-native');
const uuid = require('uuid');
let wrapped = mochaPlugin.getWrapper('createLetter', '/handler.js', 'createLetter');
const fileHelper = require('./fileHelper');


describe('createLetter Integration Tests', () => {

  afterEach(function () {
    // completely restore all fakes created through the sandbox
    sandbox.restore();
  });

  it('makes the expected request call to Slack', () => {
    const mockId = '00000000-0000-0000-0000-000000000000';
    const mockCurrentTime = new Date(2018, 1, 1);
    var event = {
      headers: { "content-type": "application/json" },
      body: fileHelper.readTextFile('test/data/createLetterValidInputBody.json')
    }

    const requestStub = sandbox.stub(request, 'post').resolves();

    // lock down the timestamp and unique ID in the request call
    sandbox.stub(Date, 'now').returns(mockCurrentTime);
    sandbox.stub(uuid, 'v4').returns(mockId);

    return wrapped.run(event).then((response) => {
      expect(response.statusCode).to.be.equal(200);
      expect(requestStub.calledOnce).to.be.true;
      const requestParam = requestStub.firstCall.args[0];
      expect(requestParam.url).to.be.equal(process.env.SLACK_WEBHOOK_URL);

      var parsedBody = requestParam.body;
      var expectedBody = fileHelper.readJsonFile('test/data/createLetterExpectedRequestBody.json');

      expect(parsedBody).to.deep.equal(expectedBody);
      expect(requestParam.json).to.be.true;

    });
  });

  it('fails when given a non-JSON body and does not call request.post()', () => {
    const requestStub = sandbox.stub(request, 'post').resolves();
    // keep test output clean, avoid logging the failure details
    var consoleStub = sandbox.stub(console, 'log');
    var event = { headers: { "content-type": "application/json" }, body: "asdf" }
    return wrapped.run(event).then((response) => {
      consoleStub.restore();
      expect(response.statusCode).to.be.equal(400);
      expect(response.body).to.be.equal("Bad request: request is not valid JSON");
      expect(requestStub.called).to.be.false;
    });
  });
});
